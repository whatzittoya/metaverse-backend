"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validate_batch_1 = require("./validate-batch");
require("../../src/types/express.d.ts");
const exceptions_1 = require("../exceptions");
const exceptions_2 = require("@directus/shared/exceptions");
let mockRequest;
let mockResponse;
const nextFunction = jest.fn();
beforeEach(() => {
    mockRequest = {};
    mockResponse = {};
    jest.clearAllMocks();
});
test('Sets body to empty, calls next on GET requests', async () => {
    mockRequest.method = 'GET';
    await (0, validate_batch_1.validateBatch)('read')(mockRequest, mockResponse, nextFunction);
    expect(mockRequest.body).toEqual({});
    expect(nextFunction).toHaveBeenCalledTimes(1);
});
test(`Short circuits on singletons that aren't queried through SEARCH`, async () => {
    mockRequest.method = 'PATCH';
    mockRequest.singleton = true;
    mockRequest.body = { title: 'test' };
    await (0, validate_batch_1.validateBatch)('update')(mockRequest, mockResponse, nextFunction);
    expect(nextFunction).toHaveBeenCalledTimes(1);
});
test('Throws InvalidPayloadException on missing body', async () => {
    mockRequest.method = 'SEARCH';
    await (0, validate_batch_1.validateBatch)('read')(mockRequest, mockResponse, nextFunction);
    expect(nextFunction).toHaveBeenCalledTimes(1);
    expect(jest.mocked(nextFunction).mock.calls[0][0]).toBeInstanceOf(exceptions_1.InvalidPayloadException);
});
test(`Short circuits on Array body in update/delete use`, async () => {
    mockRequest.method = 'PATCH';
    mockRequest.body = [1, 2, 3];
    await (0, validate_batch_1.validateBatch)('update')(mockRequest, mockResponse, nextFunction);
    expect(mockRequest.sanitizedQuery).toBe(undefined);
    expect(nextFunction).toHaveBeenCalled();
});
test(`Sets sanitizedQuery based on body.query in read operations`, async () => {
    mockRequest.method = 'SEARCH';
    mockRequest.body = {
        query: {
            sort: 'id',
        },
    };
    await (0, validate_batch_1.validateBatch)('read')(mockRequest, mockResponse, nextFunction);
    expect(mockRequest.sanitizedQuery).toEqual({
        sort: ['id'],
    });
});
test(`Doesn't allow both query and keys in a batch delete`, async () => {
    mockRequest.method = 'DELETE';
    mockRequest.body = {
        keys: [1, 2, 3],
        query: { filter: {} },
    };
    await (0, validate_batch_1.validateBatch)('delete')(mockRequest, mockResponse, nextFunction);
    expect(nextFunction).toHaveBeenCalledTimes(1);
    expect(jest.mocked(nextFunction).mock.calls[0][0]).toBeInstanceOf(exceptions_2.FailedValidationException);
});
test(`Requires 'data' on batch update`, async () => {
    mockRequest.method = 'PATCH';
    mockRequest.body = {
        keys: [1, 2, 3],
        query: { filter: {} },
    };
    await (0, validate_batch_1.validateBatch)('update')(mockRequest, mockResponse, nextFunction);
    expect(nextFunction).toHaveBeenCalledTimes(1);
    expect(jest.mocked(nextFunction).mock.calls[0][0]).toBeInstanceOf(exceptions_2.FailedValidationException);
});
test(`Calls next when all is well`, async () => {
    mockRequest.method = 'PATCH';
    mockRequest.body = {
        query: { filter: {} },
        data: {},
    };
    await (0, validate_batch_1.validateBatch)('update')(mockRequest, mockResponse, nextFunction);
    expect(nextFunction).toHaveBeenCalledTimes(1);
    expect(jest.mocked(nextFunction).mock.calls[0][0]).toBeUndefined();
});
