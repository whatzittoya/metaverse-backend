"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const knex_1 = __importDefault(require("knex"));
const knex_mock_client_1 = require("knex-mock-client");
const schemas_1 = require("../__utils__/schemas");
const services_1 = require("../services");
const apply_snapshot_1 = require("./apply-snapshot");
const getSchema = __importStar(require("./get-schema"));
const snapshots_1 = require("../__utils__/snapshots");
jest.mock('../../src/database/index', () => {
    return {
        getDatabaseClient: jest.fn().mockReturnValue('postgres'),
    };
});
jest.requireMock('../../src/database/index');
class Client_PG extends knex_mock_client_1.MockClient {
}
describe('applySnapshot', () => {
    let db;
    let tracker;
    beforeEach(() => {
        db = (0, knex_1.default)({ client: Client_PG });
        tracker = (0, knex_mock_client_1.getTracker)();
    });
    afterEach(() => {
        tracker.reset();
        jest.clearAllMocks();
    });
    describe('Creating new collection(s)', () => {
        it('Creates new top-level collection(s)', async () => {
            const expected = {
                collection: 'test_table_2',
                meta: {
                    accountability: 'all',
                    collection: 'test_table_2',
                    group: null,
                    hidden: true,
                    icon: 'import_export',
                    item_duplication_fields: null,
                    note: null,
                    singleton: false,
                    translations: {},
                },
                schema: { comment: null, name: 'test_table_2', schema: 'public' },
                fields: [
                    {
                        collection: 'test_table_2',
                        field: 'id',
                        meta: {
                            collection: 'test_table_2',
                            conditions: null,
                            display: null,
                            display_options: null,
                            field: 'id',
                            group: null,
                            hidden: true,
                            interface: null,
                            note: null,
                            options: null,
                            readonly: false,
                            required: false,
                            sort: null,
                            special: null,
                            translations: {},
                            validation: null,
                            validation_message: null,
                            width: 'full',
                        },
                        schema: {
                            comment: null,
                            data_type: 'uuid',
                            default_value: null,
                            foreign_key_column: null,
                            foreign_key_schema: null,
                            foreign_key_table: null,
                            generation_expression: null,
                            has_auto_increment: false,
                            is_generated: false,
                            is_nullable: false,
                            is_primary_key: true,
                            is_unique: true,
                            max_length: null,
                            name: 'id',
                            numeric_precision: null,
                            numeric_scale: null,
                            schema: 'public',
                            table: 'test_table_2',
                        },
                        type: 'uuid',
                    },
                ],
            };
            // Stop call to db later on in apply-snapshot
            jest.spyOn(getSchema, 'getSchema').mockReturnValue(Promise.resolve(schemas_1.snapshotApplyTestSchema));
            // We are not actually testing that createOne works, just that is is called correctly
            const createOneCollectionSpy = jest
                .spyOn(services_1.CollectionsService.prototype, 'createOne')
                .mockImplementation(jest.fn());
            const createFieldSpy = jest.spyOn(services_1.FieldsService.prototype, 'createField').mockImplementation(jest.fn());
            await (0, apply_snapshot_1.applySnapshot)(snapshots_1.snapshotCreateCollectionNotNested, {
                database: db,
                current: snapshots_1.snapshotBeforeCreateCollection,
                schema: schemas_1.snapshotApplyTestSchema,
            });
            expect(createOneCollectionSpy).toHaveBeenCalledTimes(1);
            expect(createOneCollectionSpy).toHaveBeenCalledWith(expected);
            // There should be no fields left to create
            // they will get filtered in createCollections
            expect(createFieldSpy).toHaveBeenCalledTimes(0);
        });
        it('Creates the highest-level nested collection(s) with existing parents and any children', async () => {
            const expected = {
                collection: 'test_table_2',
                meta: {
                    accountability: 'all',
                    collection: 'test_table_2',
                    group: 'test_table',
                    hidden: true,
                    icon: 'import_export',
                    item_duplication_fields: null,
                    note: null,
                    singleton: false,
                    translations: {},
                },
                schema: { comment: null, name: 'test_table_2', schema: 'public' },
                fields: [
                    {
                        collection: 'test_table_2',
                        field: 'id',
                        meta: {
                            collection: 'test_table_2',
                            conditions: null,
                            display: null,
                            display_options: null,
                            field: 'id',
                            group: null,
                            hidden: true,
                            interface: null,
                            note: null,
                            options: null,
                            readonly: false,
                            required: false,
                            sort: null,
                            special: null,
                            translations: {},
                            validation: null,
                            validation_message: null,
                            width: 'full',
                        },
                        schema: {
                            comment: null,
                            data_type: 'uuid',
                            default_value: null,
                            foreign_key_column: null,
                            foreign_key_schema: null,
                            foreign_key_table: null,
                            generation_expression: null,
                            has_auto_increment: false,
                            is_generated: false,
                            is_nullable: false,
                            is_primary_key: true,
                            is_unique: true,
                            max_length: null,
                            name: 'id',
                            numeric_precision: null,
                            numeric_scale: null,
                            schema: 'public',
                            table: 'test_table_2',
                        },
                        type: 'uuid',
                    },
                ],
            };
            const expected2 = {
                collection: 'test_table_3',
                fields: [
                    {
                        collection: 'test_table_3',
                        field: 'id',
                        meta: {
                            collection: 'test_table_3',
                            conditions: null,
                            display: null,
                            display_options: null,
                            field: 'id',
                            group: null,
                            hidden: true,
                            interface: null,
                            note: null,
                            options: null,
                            readonly: false,
                            required: false,
                            sort: null,
                            special: null,
                            translations: {},
                            validation: null,
                            validation_message: null,
                            width: 'full',
                        },
                        schema: {
                            comment: null,
                            data_type: 'uuid',
                            default_value: null,
                            foreign_key_column: null,
                            foreign_key_schema: null,
                            foreign_key_table: null,
                            generation_expression: null,
                            has_auto_increment: false,
                            is_generated: false,
                            is_nullable: false,
                            is_primary_key: true,
                            is_unique: true,
                            max_length: null,
                            name: 'id',
                            numeric_precision: null,
                            numeric_scale: null,
                            schema: 'public',
                            table: 'test_table_3',
                        },
                        type: 'uuid',
                    },
                ],
                meta: {
                    accountability: 'all',
                    collection: 'test_table_3',
                    group: 'test_table_2',
                    hidden: true,
                    icon: 'import_export',
                    item_duplication_fields: null,
                    note: null,
                    singleton: false,
                    translations: {},
                },
                schema: { comment: null, name: 'test_table_3', schema: 'public' },
            };
            // Stop call to db later on in apply-snapshot
            jest.spyOn(getSchema, 'getSchema').mockReturnValue(Promise.resolve(schemas_1.snapshotApplyTestSchema));
            // We are not actually testing that createOne works, just that is is called correctly
            const createOneCollectionSpy = jest
                .spyOn(services_1.CollectionsService.prototype, 'createOne')
                .mockImplementation(jest.fn());
            const createFieldSpy = jest.spyOn(services_1.FieldsService.prototype, 'createField').mockImplementation(jest.fn());
            await (0, apply_snapshot_1.applySnapshot)(snapshots_1.snapshotCreateCollection, {
                database: db,
                current: snapshots_1.snapshotBeforeCreateCollection,
                schema: schemas_1.snapshotApplyTestSchema,
            });
            expect(createOneCollectionSpy).toHaveBeenCalledTimes(2);
            expect(createOneCollectionSpy).toHaveBeenCalledWith(expected);
            expect(createOneCollectionSpy).toHaveBeenCalledWith(expected2);
            // There should be no fields left to create
            // they will get filtered in createCollections
            expect(createFieldSpy).toHaveBeenCalledTimes(0);
        });
    });
    describe('Delete collections', () => {
        it('Deletes interrelated collections', async () => {
            const snapshotToApply = {
                version: 1,
                directus: '0.0.0',
                collections: [],
                fields: [],
                relations: [],
            };
            // Stop call to db later on in apply-snapshot
            jest.spyOn(getSchema, 'getSchema').mockReturnValue(Promise.resolve(schemas_1.snapshotApplyTestSchema));
            // We are not actually testing that deleteOne works, just that is is called correctly
            const deleteOneCollectionSpy = jest
                .spyOn(services_1.CollectionsService.prototype, 'deleteOne')
                .mockImplementation(jest.fn());
            await (0, apply_snapshot_1.applySnapshot)(snapshotToApply, {
                database: db,
                current: snapshots_1.snapshotBeforeDeleteCollection,
                schema: schemas_1.snapshotApplyTestSchema,
            });
            expect(deleteOneCollectionSpy).toHaveBeenCalledTimes(3);
        });
    });
});
