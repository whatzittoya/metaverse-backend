"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const exifr_1 = __importDefault(require("exifr"));
const knex_1 = __importDefault(require("knex"));
const knex_mock_client_1 = require("knex-mock-client");
const _1 = require(".");
jest.mock('exifr');
jest.mock('../../src/database/index', () => {
    return { getDatabaseClient: jest.fn().mockReturnValue('postgres') };
});
jest.requireMock('../../src/database/index');
describe('Integration Tests', () => {
    let db;
    let tracker;
    beforeAll(async () => {
        db = (0, knex_1.default)({ client: knex_mock_client_1.MockClient });
        tracker = (0, knex_mock_client_1.getTracker)();
    });
    afterEach(() => {
        tracker.reset();
    });
    describe('Services / Files', () => {
        describe('getMetadata', () => {
            let service;
            let exifrParseSpy;
            const sampleMetadata = {
                CustomTagA: 'value a',
                CustomTagB: 'value b',
                CustomTagC: 'value c',
            };
            beforeEach(() => {
                exifrParseSpy = jest.spyOn(exifr_1.default, 'parse');
                service = new _1.FilesService({
                    knex: db,
                    schema: { collections: {}, relations: [] },
                });
            });
            it('accepts allowlist metadata tags', async () => {
                exifrParseSpy.mockReturnValue(Promise.resolve({ ...sampleMetadata }));
                const bufferContent = 'file buffer content';
                const allowList = ['CustomTagB', 'CustomTagA'];
                const metadata = await service.getMetadata(bufferContent, allowList);
                expect(exifrParseSpy).toHaveBeenCalled();
                expect(metadata.metadata.CustomTagA).toStrictEqual(sampleMetadata.CustomTagA);
                expect(metadata.metadata.CustomTagB).toStrictEqual(sampleMetadata.CustomTagB);
                expect(metadata.metadata.CustomTagC).toBeUndefined();
            });
        });
    });
});
