import{a as n,o as d,b as c,w as a,l as e,E as t,e as l}from"./runtime-core.esm-bundler.fe249c5c.js";const u={class:"markdown-body"},h=e("blockquote",null,[e("p",null,"This pane controls the technical details of the field\u2019s database column.")],-1),p=e("strong",null,"Key",-1),m=e("strong",null,"Type",-1),_=e("li",null,[e("strong",null,"Length"),t(" \u2014 (Only for certain types) For String types this determines the number of characters that can be stored in the database. For Float and Decimal types, this control becomes "),e("strong",null,"Precision & Scale"),t(".")],-1),y=e("li",null,[e("strong",null,"On Create"),t(" \u2014 (Only for certain types) For some data types, this option allows you to control what value is saved when an item is created. These values are fallbacks and can be overridden by the App/API. For example, the Timestamp type allows you to \u201CSave Current Date/Time\u201D.")],-1),f=e("li",null,[e("strong",null,"On Update"),t(" \u2014 (Only for certain types) For some data types, this option allows you to control what value is saved when an item is updated. These values are fallbacks and can be overridden by the App/API. For example, the UUID type allows you to \u201CSave Current User ID\u201D.")],-1),b=e("li",null,[e("strong",null,"Default Value"),t(" \u2014 This is the initial value shown for a field when creating an item in the App. If creating an item via the API, this is the fallback value saved to the database if a field value is not submitted.")],-1),v=e("li",null,[e("strong",null,"Allow NULL"),t(" \u2014 Toggles if the database column is nullable. When disabled, a "),e("code",null,"NULL"),t(" value can not be saved to the field\u2019s column.")],-1),w=e("li",null,[e("strong",null,"Unique"),t(" \u2014 Toggles if the database column\u2019s values must all be unique.")],-1),g=e("div",{class:"danger hint"},[e("div",{class:"hint-title"},"Immutable Keys"),e("p",null,"As of now, the key cannot be modified after the field has been created.")],-1),T=e("div",{class:"warning hint"},[e("div",{class:"hint-title"},"Composite Keys"),e("p",null,"At this time, Directus does not support composite keys.")],-1),D="Schema",I=!1,S={__name:"schema",setup(k,{expose:i}){const s={title:"Schema",modularExtension:!1};return i({frontmatter:s}),(A,F)=>{const o=n("router-link"),r=n("docs-wrapper");return d(),c(r,{frontmatter:s},{default:a(()=>[e("div",u,[h,e("ul",null,[e("li",null,[p,t(" \u2014 (Required) The database column name and field\u2019s API key. The key must be unique within its parent Collection. As of now, all keys are sanitized: lowercased, alphanumeric, and with spaces removed. Keys can not be changed once created, however you can use "),l(o,{to:"/docs/configuration/data-model#field"},{default:a(()=>[t("Field Name Translations")]),_:1}),t(" to override how it\u2019s displayed in the App.")]),e("li",null,[m,t(" \u2014 (Required) How the data is saved to the database; See "),l(o,{to:"/docs/getting-started/glossary#data-type-superset"},{default:a(()=>[t("Directus Data Type Superset")]),_:1}),t(". This dropdown may be limited or even disabled based on your chosen Field category.")]),_,y,f,b,v,w]),g,T])]),_:1})}}};export{S as default,I as modularExtension,D as title};
